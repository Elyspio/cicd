/* tslint:disable */
/* eslint-disable */
/**
 * Api documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosInstance, AxiosPromise } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	assertParamExists,
	createRequestFunction,
	DUMMY_BASE_URL,
	serializeDataIfNeeded,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	toPathString,
} from "./common";
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from "./base";

/**
 *
 * @export
 * @interface BuildAgentModelAdd
 */
export interface BuildAgentModelAdd {
	/**
	 *
	 * @type {string}
	 * @memberof BuildAgentModelAdd
	 */
	uri: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof BuildAgentModelAdd
	 */
	abilities: Array<BuildAgentModelAddAbilitiesEnum>;
}

/**
 * @export
 * @enum {string}
 */
export enum BuildAgentModelAddAbilitiesEnum {
	Docker = "docker",
	DockerBuildx = "docker-buildx",
}

/**
 *
 * @export
 * @interface BuildAgentModelReturn
 */
export interface BuildAgentModelReturn {
	/**
	 *
	 * @type {string}
	 * @memberof BuildAgentModelReturn
	 */
	uri: string;
	/**
	 *
	 * @type {string}
	 * @memberof BuildAgentModelReturn
	 */
	availability: BuildAgentModelReturnAvailabilityEnum;
	/**
	 *
	 * @type {string}
	 * @memberof BuildAgentModelReturn
	 */
	lastUptime?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof BuildAgentModelReturn
	 */
	abilities: Array<BuildAgentModelReturnAbilitiesEnum>;
}

/**
 * @export
 * @enum {string}
 */
export enum BuildAgentModelReturnAvailabilityEnum {
	Free = "free",
	Running = "running",
	Down = "down",
}

/**
 * @export
 * @enum {string}
 */
export enum BuildAgentModelReturnAbilitiesEnum {
	Docker = "docker",
	DockerBuildx = "docker-buildx",
}

/**
 *
 * @export
 * @interface BuildConfigModel
 */
export interface BuildConfigModel {
	/**
	 *
	 * @type {GithubConfigModel}
	 * @memberof BuildConfigModel
	 */
	github: GithubConfigModel;
	/**
	 *
	 * @type {DockerConfigModel}
	 * @memberof BuildConfigModel
	 */
	dockerfiles?: DockerConfigModel;
	/**
	 *
	 * @type {DockerBakeModel}
	 * @memberof BuildConfigModel
	 */
	bake?: DockerBakeModel;
}

/**
 *
 * @export
 * @interface DeployConfigModel
 */
export interface DeployConfigModel {
	/**
	 *
	 * @type {DockerField}
	 * @memberof DeployConfigModel
	 */
	docker: DockerField;
	/**
	 * URI of the production agent
	 * @type {string}
	 * @memberof DeployConfigModel
	 */
	uri: string;
}

/**
 *
 * @export
 * @interface DockerBakeModel
 */
export interface DockerBakeModel {
	/**
	 *
	 * @type {string}
	 * @memberof DockerBakeModel
	 */
	bakeFilePath: string;
}

/**
 *
 * @export
 * @interface DockerComposeField
 */
export interface DockerComposeField {
	/**
	 * Path where the docker-compose.yml file is
	 * @type {string}
	 * @memberof DockerComposeField
	 */
	path?: string;
}

/**
 *
 * @export
 * @interface DockerConfigModel
 */
export interface DockerConfigModel {
	/**
	 * Dockerfiles to build
	 * @type {Array<DockerFileConfigModel>}
	 * @memberof DockerConfigModel
	 */
	files: Array<DockerFileConfigModel>;
	/**
	 * Platforms available for the future image
	 * @type {Array<string>}
	 * @memberof DockerConfigModel
	 */
	platforms: Array<DockerConfigModelPlatformsEnum>;
	/**
	 *
	 * @type {string}
	 * @memberof DockerConfigModel
	 */
	username: string;
}

/**
 * @export
 * @enum {string}
 */
export enum DockerConfigModelPlatformsEnum {
	Arm64 = "linux/arm64",
	Amd64 = "linux/amd64",
}

/**
 *
 * @export
 * @interface DockerField
 */
export interface DockerField {
	/**
	 *
	 * @type {DockerComposeField}
	 * @memberof DockerField
	 */
	compose?: DockerComposeField;
}

/**
 *
 * @export
 * @interface DockerFileConfigModel
 */
export interface DockerFileConfigModel {
	/**
	 * Path to Dockerfile file
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	path: string;
	/**
	 * Working directory from origin
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	wd: string;
	/**
	 * Name for the image
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	image: string;
	/**
	 * Tag for the image
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	tag?: string;
}

/**
 *
 * @export
 * @interface FileModel
 */
export interface FileModel {
	/**
	 *
	 * @type {string}
	 * @memberof FileModel
	 */
	path: string;
	/**
	 *
	 * @type {string}
	 * @memberof FileModel
	 */
	key: string;
	/**
	 *
	 * @type {number}
	 * @memberof FileModel
	 */
	size: number;
}

/**
 *
 * @export
 * @interface FoldersModel
 */
export interface FoldersModel {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof FoldersModel
	 */
	apps: Array<string>;
}

/**
 *
 * @export
 * @interface GenericError
 */
export interface GenericError {
	/**
	 * The error name
	 * @type {string}
	 * @memberof GenericError
	 */
	name: string;
	/**
	 * An error message
	 * @type {string}
	 * @memberof GenericError
	 */
	message: string;

	[key: string]: object | any;
}

/**
 *
 * @export
 * @interface GithubConfigModel
 */
export interface GithubConfigModel {
	/**
	 * Url of the repo
	 * @type {string}
	 * @memberof GithubConfigModel
	 */
	remote: string;
	/**
	 * Branch on the repo
	 * @type {string}
	 * @memberof GithubConfigModel
	 */
	branch: string;
	/**
	 * Commit Sha
	 * @type {string}
	 * @memberof GithubConfigModel
	 */
	commit?: string;
}

/**
 *
 * @export
 * @interface GithubPushWebhook
 */
export interface GithubPushWebhook {
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	ref: string;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	before: string;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	after: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof GithubPushWebhook
	 */
	created: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof GithubPushWebhook
	 */
	deleted: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof GithubPushWebhook
	 */
	forced: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	base_ref: string;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	compare: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof GithubPushWebhook
	 */
	commits: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	head_commit?: string;
	/**
	 *
	 * @type {Repository}
	 * @memberof GithubPushWebhook
	 */
	repository: Repository;
	/**
	 *
	 * @type {Pusher}
	 * @memberof GithubPushWebhook
	 */
	pusher: Pusher;
	/**
	 *
	 * @type {User}
	 * @memberof GithubPushWebhook
	 */
	sender: User;
}

/**
 *
 * @export
 * @interface HubAgentConfig
 */
export interface HubAgentConfig {
	/**
	 *
	 * @type {Array<ProductionAgentModel>}
	 * @memberof HubAgentConfig
	 */
	production: Array<ProductionAgentModel>;
	/**
	 *
	 * @type {Array<BuildAgentModelReturn>}
	 * @memberof HubAgentConfig
	 */
	builder: Array<BuildAgentModelReturn>;
}

/**
 *
 * @export
 * @interface HubConfig
 */
export interface HubConfig {
	/**
	 *
	 * @type {HubAgentConfig}
	 * @memberof HubConfig
	 */
	agents: HubAgentConfig;
	/**
	 *
	 * @type {JobsModel}
	 * @memberof HubConfig
	 */
	jobs: JobsModel;
	/**
	 *
	 * @type {Array<MappingModel>}
	 * @memberof HubConfig
	 */
	mappings: Array<MappingModel>;
	/**
	 *
	 * @type {JobsModel}
	 * @memberof HubConfig
	 */
	queues: JobsModel;
}

/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
	/**
	 *
	 * @type {string}
	 * @memberof InlineObject
	 */
	url: string;
}

/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
	/**
	 *
	 * @type {string}
	 * @memberof InlineObject1
	 */
	url: string;
}

/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
	/**
	 *
	 * @type {BuildConfigModel}
	 * @memberof InlineObject2
	 */
	build: BuildConfigModel;
	/**
	 *
	 * @type {DeployConfigModel}
	 * @memberof InlineObject2
	 */
	deploy: DeployConfigModel;
}

/**
 *
 * @export
 * @interface JobBuildModel
 */
export interface JobBuildModel {
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	startedAt?: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	finishedAt?: string;
	/**
	 *
	 * @type {number}
	 * @memberof JobBuildModel
	 */
	id: number;
	/**
	 *
	 * @type {BuildConfigModel}
	 * @memberof JobBuildModel
	 */
	config: BuildConfigModel;
}

/**
 *
 * @export
 * @interface JobDeployModel
 */
export interface JobDeployModel {
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	startedAt?: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	finishedAt?: string;
	/**
	 *
	 * @type {number}
	 * @memberof JobDeployModel
	 */
	id: number;
	/**
	 *
	 * @type {DeployConfigModel}
	 * @memberof JobDeployModel
	 */
	config: DeployConfigModel;
}

/**
 *
 * @export
 * @interface JobsModel
 */
export interface JobsModel {
	/**
	 *
	 * @type {Array<JobBuildModel>}
	 * @memberof JobsModel
	 */
	builds: Array<JobBuildModel>;
	/**
	 *
	 * @type {Array<JobDeployModel>}
	 * @memberof JobsModel
	 */
	deployments: Array<JobDeployModel>;
}

/**
 *
 * @export
 * @interface MappingModel
 */
export interface MappingModel {
	/**
	 *
	 * @type {BuildConfigModel}
	 * @memberof MappingModel
	 */
	build: BuildConfigModel;
	/**
	 *
	 * @type {DeployConfigModel}
	 * @memberof MappingModel
	 */
	deploy: DeployConfigModel;
	/**
	 *
	 * @type {number}
	 * @memberof MappingModel
	 */
	id: number;
}

/**
 *
 * @export
 * @interface ProductionAgentModel
 */
export interface ProductionAgentModel {
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModel
	 */
	uri: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModel
	 */
	availability: ProductionAgentModelAvailabilityEnum;
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModel
	 */
	lastUptime?: string;
	/**
	 *
	 * @type {Array<ProductionAgentModelAddAbilities>}
	 * @memberof ProductionAgentModel
	 */
	abilities: Array<ProductionAgentModelAddAbilities>;
	/**
	 *
	 * @type {FoldersModel}
	 * @memberof ProductionAgentModel
	 */
	folders: FoldersModel;
}

/**
 * @export
 * @enum {string}
 */
export enum ProductionAgentModelAvailabilityEnum {
	Free = "free",
	Running = "running",
	Down = "down",
}

/**
 *
 * @export
 * @interface ProductionAgentModelAdd
 */
export interface ProductionAgentModelAdd {
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModelAdd
	 */
	uri: string;
	/**
	 *
	 * @type {Array<ProductionAgentModelAddAbilities>}
	 * @memberof ProductionAgentModelAdd
	 */
	abilities: Array<ProductionAgentModelAddAbilities>;
	/**
	 *
	 * @type {FoldersModel}
	 * @memberof ProductionAgentModelAdd
	 */
	folders: FoldersModel;
}

/**
 *
 * @export
 * @interface ProductionAgentModelAddAbilities
 */
export interface ProductionAgentModelAddAbilities {
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModelAddAbilities
	 */
	type: ProductionAgentModelAddAbilitiesTypeEnum;
	/**
	 *
	 * @type {ProductionAgentModelAddAbilitiesDockerCompose}
	 * @memberof ProductionAgentModelAddAbilities
	 */
	dockerCompose?: ProductionAgentModelAddAbilitiesDockerCompose;
}

/**
 * @export
 * @enum {string}
 */
export enum ProductionAgentModelAddAbilitiesTypeEnum {
	DockerCompose = "docker-compose",
	Docker = "docker",
}

/**
 *
 * @export
 * @interface ProductionAgentModelAddAbilitiesDockerCompose
 */
export interface ProductionAgentModelAddAbilitiesDockerCompose {
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductionAgentModelAddAbilitiesDockerCompose
	 */
	isDockerComposeIntegratedToCli: boolean;
}

/**
 *
 * @export
 * @interface ProductionApplications
 */
export interface ProductionApplications {
	/**
	 *
	 * @type {ProductionAgentModel}
	 * @memberof ProductionApplications
	 */
	agent: ProductionAgentModel;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ProductionApplications
	 */
	apps: Array<string>;
}

/**
 *
 * @export
 * @interface Pusher
 */
export interface Pusher {
	/**
	 *
	 * @type {string}
	 * @memberof Pusher
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Pusher
	 */
	email: string;
}

/**
 *
 * @export
 * @interface RepoNodeModel
 */
export interface RepoNodeModel {
	/**
	 *
	 * @type {string}
	 * @memberof RepoNodeModel
	 */
	path: string;
	/**
	 *
	 * @type {string}
	 * @memberof RepoNodeModel
	 */
	type: RepoNodeModelTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum RepoNodeModelTypeEnum {
	Folder = "folder",
	File = "file",
}

/**
 *
 * @export
 * @interface RepoWithBranchModel
 */
export interface RepoWithBranchModel {
	/**
	 *
	 * @type {string}
	 * @memberof RepoWithBranchModel
	 */
	branch: string;
	/**
	 *
	 * @type {string}
	 * @memberof RepoWithBranchModel
	 */
	repo: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof RepoWithBranchModel
	 */
	dockerfiles: Array<string>;
	/**
	 *
	 * @type {Array<RepoNodeModel>}
	 * @memberof RepoWithBranchModel
	 */
	nodes: Array<RepoNodeModel>;
	/**
	 *
	 * @type {string}
	 * @memberof RepoWithBranchModel
	 */
	bake?: string;
}

/**
 *
 * @export
 * @interface Repository
 */
export interface Repository {
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	id: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	node_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	full_name: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	_private: boolean;
	/**
	 *
	 * @type {User}
	 * @memberof Repository
	 */
	owner: User;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	html_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	description: string | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	fork: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	forks_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	keys_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	collaborators_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	teams_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	hooks_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	issue_events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	assignees_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	branches_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	tags_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	blobs_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_tags_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_refs_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	trees_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	statuses_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	languages_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	stargazers_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	contributors_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	subscribers_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	subscription_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	commits_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_commits_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	comments_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	issue_comment_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	contents_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	compare_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	merges_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	archive_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	downloads_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	issues_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	pulls_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	milestones_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	notifications_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	labels_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	releases_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	deployments_url: string;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	created_at: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	updated_at: string;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	pushed_at: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	ssh_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	clone_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	svn_url: string;
	/**
	 *
	 * @type {object}
	 * @memberof Repository
	 */
	homepage: object;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	size: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	stargazers_count: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	watchers_count: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	language: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_issues: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_projects: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_downloads: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_wiki: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_pages: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	forks_count: number;
	/**
	 *
	 * @type {object}
	 * @memberof Repository
	 */
	mirror_url: object;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	archived: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	disabled: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	open_issues_count: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	license: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	forks: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	open_issues: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	watchers: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	default_branch: string;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	stargazers: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	master_branch: string;
}

/**
 *
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
	/**
	 * The error name
	 * @type {string}
	 * @memberof Unauthorized
	 */
	name: string;
	/**
	 * An error message
	 * @type {string}
	 * @memberof Unauthorized
	 */
	message: string;
	/**
	 * The status code of the exception
	 * @type {number}
	 * @memberof Unauthorized
	 */
	status: number;
	/**
	 * A list of related errors
	 * @type {Array<GenericError>}
	 * @memberof Unauthorized
	 */
	errors?: Array<GenericError>;
	/**
	 * The stack trace (only in development mode)
	 * @type {string}
	 * @memberof Unauthorized
	 */
	stack?: string;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	email: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	login: string;
	/**
	 *
	 * @type {number}
	 * @memberof User
	 */
	id: number;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	node_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	avatar_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	gravatar_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	html_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	followers_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	following_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	gists_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	starred_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	subscriptions_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	organizations_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	repos_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	received_events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	type: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof User
	 */
	site_admin: boolean;
}

/**
 * AutomationApi - axios parameter creator
 * @export
 */
export const AutomationApiAxiosParamCreator = function(
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @param {BuildAgentModelAdd} buildAgentModelAdd
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addBuildAgent: async (
			buildAgentModelAdd: BuildAgentModelAdd,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'buildAgentModelAdd' is not null or undefined
			assertParamExists(
				"addBuildAgent",
				"buildAgentModelAdd",
				buildAgentModelAdd,
			);
			const localVarPath = `/api/automate/agent/build`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				buildAgentModelAdd,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {ProductionAgentModelAdd} productionAgentModelAdd
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addProductionAgent: async (
			productionAgentModelAdd: ProductionAgentModelAdd,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productionAgentModelAdd' is not null or undefined
			assertParamExists(
				"addProductionAgent",
				"productionAgentModelAdd",
				productionAgentModelAdd,
			);
			const localVarPath = `/api/automate/agent/production`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productionAgentModelAdd,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {InlineObject} inlineObject
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		builderAgentKeepAlive: async (
			inlineObject: InlineObject,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inlineObject' is not null or undefined
			assertParamExists(
				"builderAgentKeepAlive",
				"inlineObject",
				inlineObject,
			);
			const localVarPath = `/api/automate/agent/build/keep-alive`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inlineObject,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBuilderAgent: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/automate/agent/build`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionAgent: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/automate/agent/production`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionApps: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/automate/agent/production/node`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {InlineObject1} inlineObject1
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productionAgentKeepAlive: async (
			inlineObject1: InlineObject1,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inlineObject1' is not null or undefined
			assertParamExists(
				"productionAgentKeepAlive",
				"inlineObject1",
				inlineObject1,
			);
			const localVarPath = `/api/automate/agent/production/keep-alive`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inlineObject1,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * AutomationApi - functional programming interface
 * @export
 */
export const AutomationApiFp = function(configuration?: Configuration) {
	const localVarAxiosParamCreator =
		AutomationApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {BuildAgentModelAdd} buildAgentModelAdd
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addBuildAgent(
			buildAgentModelAdd: BuildAgentModelAdd,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addBuildAgent(
					buildAgentModelAdd,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {ProductionAgentModelAdd} productionAgentModelAdd
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addProductionAgent(
			productionAgentModelAdd: ProductionAgentModelAdd,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addProductionAgent(
					productionAgentModelAdd,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {InlineObject} inlineObject
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async builderAgentKeepAlive(
			inlineObject: InlineObject,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.builderAgentKeepAlive(
					inlineObject,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBuilderAgent(
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<BuildAgentModelReturn>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getBuilderAgent(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getProductionAgent(
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<ProductionAgentModel>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getProductionAgent(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getProductionApps(
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<ProductionApplications>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getProductionApps(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {InlineObject1} inlineObject1
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productionAgentKeepAlive(
			inlineObject1: InlineObject1,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productionAgentKeepAlive(
					inlineObject1,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
	};
};

/**
 * AutomationApi - factory interface
 * @export
 */
export const AutomationApiFactory = function(
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = AutomationApiFp(configuration);
	return {
		/**
		 *
		 * @param {BuildAgentModelAdd} buildAgentModelAdd
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addBuildAgent(
			buildAgentModelAdd: BuildAgentModelAdd,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.addBuildAgent(buildAgentModelAdd, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {ProductionAgentModelAdd} productionAgentModelAdd
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addProductionAgent(
			productionAgentModelAdd: ProductionAgentModelAdd,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.addProductionAgent(productionAgentModelAdd, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {InlineObject} inlineObject
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		builderAgentKeepAlive(
			inlineObject: InlineObject,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.builderAgentKeepAlive(inlineObject, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBuilderAgent(
			options?: any,
		): AxiosPromise<Array<BuildAgentModelReturn>> {
			return localVarFp
				.getBuilderAgent(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionAgent(
			options?: any,
		): AxiosPromise<Array<ProductionAgentModel>> {
			return localVarFp
				.getProductionAgent(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionApps(
			options?: any,
		): AxiosPromise<Array<ProductionApplications>> {
			return localVarFp
				.getProductionApps(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {InlineObject1} inlineObject1
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productionAgentKeepAlive(
			inlineObject1: InlineObject1,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.productionAgentKeepAlive(inlineObject1, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * AutomationApi - object-oriented interface
 * @export
 * @class AutomationApi
 * @extends {BaseAPI}
 */
export class AutomationApi extends BaseAPI {
	/**
	 *
	 * @param {BuildAgentModelAdd} buildAgentModelAdd
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomationApi
	 */
	public addBuildAgent(
		buildAgentModelAdd: BuildAgentModelAdd,
		options?: any,
	) {
		return AutomationApiFp(this.configuration)
			.addBuildAgent(buildAgentModelAdd, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ProductionAgentModelAdd} productionAgentModelAdd
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomationApi
	 */
	public addProductionAgent(
		productionAgentModelAdd: ProductionAgentModelAdd,
		options?: any,
	) {
		return AutomationApiFp(this.configuration)
			.addProductionAgent(productionAgentModelAdd, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {InlineObject} inlineObject
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomationApi
	 */
	public builderAgentKeepAlive(inlineObject: InlineObject, options?: any) {
		return AutomationApiFp(this.configuration)
			.builderAgentKeepAlive(inlineObject, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomationApi
	 */
	public getBuilderAgent(options?: any) {
		return AutomationApiFp(this.configuration)
			.getBuilderAgent(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomationApi
	 */
	public getProductionAgent(options?: any) {
		return AutomationApiFp(this.configuration)
			.getProductionAgent(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomationApi
	 */
	public getProductionApps(options?: any) {
		return AutomationApiFp(this.configuration)
			.getProductionApps(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {InlineObject1} inlineObject1
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomationApi
	 */
	public productionAgentKeepAlive(
		inlineObject1: InlineObject1,
		options?: any,
	) {
		return AutomationApiFp(this.configuration)
			.productionAgentKeepAlive(inlineObject1, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * DockerControllerApi - axios parameter creator
 * @export
 */
export const DockerControllerApiAxiosParamCreator = function(
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @param {Array<'web-front' | 'web-back'>} [preset]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		get: async (
			preset?: Array<"web-front" | "web-back">,
			options: any = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/docker/dockerfiles`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (preset) {
				localVarQueryParameter["preset"] = preset;
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * DockerControllerApi - functional programming interface
 * @export
 */
export const DockerControllerApiFp = function(configuration?: Configuration) {
	const localVarAxiosParamCreator =
		DockerControllerApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {Array<'web-front' | 'web-back'>} [preset]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async get(
			preset?: Array<"web-front" | "web-back">,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.get(
				preset,
				options,
			);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
	};
};

/**
 * DockerControllerApi - factory interface
 * @export
 */
export const DockerControllerApiFactory = function(
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = DockerControllerApiFp(configuration);
	return {
		/**
		 *
		 * @param {Array<'web-front' | 'web-back'>} [preset]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		get(
			preset?: Array<"web-front" | "web-back">,
			options?: any,
		): AxiosPromise<string> {
			return localVarFp
				.get(preset, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * DockerControllerApi - object-oriented interface
 * @export
 * @class DockerControllerApi
 * @extends {BaseAPI}
 */
export class DockerControllerApi extends BaseAPI {
	/**
	 *
	 * @param {Array<'web-front' | 'web-back'>} [preset]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DockerControllerApi
	 */
	public get(preset?: Array<"web-front" | "web-back">, options?: any) {
		return DockerControllerApiFp(this.configuration)
			.get(preset, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * GithubApi - axios parameter creator
 * @export
 */
export const GithubApiAxiosParamCreator = function(
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBranchesForRepository: async (
			username: string,
			repository: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists("getBranchesForRepository", "username", username);
			// verify required parameter 'repository' is not null or undefined
			assertParamExists(
				"getBranchesForRepository",
				"repository",
				repository,
			);
			const localVarPath =
				`/api/github/users/{username}/repositories/{repository}/branches`
					.replace(
						`{${"username"}}`,
						encodeURIComponent(String(username)),
					)
					.replace(
						`{${"repository"}}`,
						encodeURIComponent(String(repository)),
					);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (
				authenticationToken !== undefined &&
				authenticationToken !== null
			) {
				localVarHeaderParameter["authentication-token"] =
					String(authenticationToken);
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerRepository: async (
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists("getDockerRepository", "username", username);
			const localVarPath =
				`/api/github/users/{username}/repositories/dockerfiles`.replace(
					`{${"username"}}`,
					encodeURIComponent(String(username)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (
				authenticationToken !== undefined &&
				authenticationToken !== null
			) {
				localVarHeaderParameter["authentication-token"] =
					String(authenticationToken);
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} branch
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerfilesForRepository: async (
			username: string,
			repository: string,
			branch: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists(
				"getDockerfilesForRepository",
				"username",
				username,
			);
			// verify required parameter 'repository' is not null or undefined
			assertParamExists(
				"getDockerfilesForRepository",
				"repository",
				repository,
			);
			// verify required parameter 'branch' is not null or undefined
			assertParamExists("getDockerfilesForRepository", "branch", branch);
			const localVarPath =
				`/api/github/users/{username}/repositories/{repository}/branches/{branch}/dockerfiles`
					.replace(
						`{${"username"}}`,
						encodeURIComponent(String(username)),
					)
					.replace(
						`{${"repository"}}`,
						encodeURIComponent(String(repository)),
					)
					.replace(
						`{${"branch"}}`,
						encodeURIComponent(String(branch)),
					);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (
				authenticationToken !== undefined &&
				authenticationToken !== null
			) {
				localVarHeaderParameter["authentication-token"] =
					String(authenticationToken);
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRepositories: async (
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists("getRepositories", "username", username);
			const localVarPath = `/api/github/users/{username}`.replace(
				`{${"username"}}`,
				encodeURIComponent(String(username)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (
				authenticationToken !== undefined &&
				authenticationToken !== null
			) {
				localVarHeaderParameter["authentication-token"] =
					String(authenticationToken);
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * GithubApi - functional programming interface
 * @export
 */
export const GithubApiFp = function(configuration?: Configuration) {
	const localVarAxiosParamCreator = GithubApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBranchesForRepository(
			username: string,
			repository: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<string>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getBranchesForRepository(
					username,
					repository,
					authenticationToken,
					authenticationToken2,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getDockerRepository(
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<RepoWithBranchModel>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getDockerRepository(
					username,
					authenticationToken,
					authenticationToken2,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} branch
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getDockerfilesForRepository(
			username: string,
			repository: string,
			branch: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<FileModel>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getDockerfilesForRepository(
					username,
					repository,
					branch,
					authenticationToken,
					authenticationToken2,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getRepositories(
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<string>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getRepositories(
					username,
					authenticationToken,
					authenticationToken2,
					options,
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
	};
};

/**
 * GithubApi - factory interface
 * @export
 */
export const GithubApiFactory = function(
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = GithubApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBranchesForRepository(
			username: string,
			repository: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): AxiosPromise<Array<string>> {
			return localVarFp
				.getBranchesForRepository(
					username,
					repository,
					authenticationToken,
					authenticationToken2,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerRepository(
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): AxiosPromise<Array<RepoWithBranchModel>> {
			return localVarFp
				.getDockerRepository(
					username,
					authenticationToken,
					authenticationToken2,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} branch
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerfilesForRepository(
			username: string,
			repository: string,
			branch: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): AxiosPromise<Array<FileModel>> {
			return localVarFp
				.getDockerfilesForRepository(
					username,
					repository,
					branch,
					authenticationToken,
					authenticationToken2,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRepositories(
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any,
		): AxiosPromise<Array<string>> {
			return localVarFp
				.getRepositories(
					username,
					authenticationToken,
					authenticationToken2,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * GithubApi - object-oriented interface
 * @export
 * @class GithubApi
 * @extends {BaseAPI}
 */
export class GithubApi extends BaseAPI {
	/**
	 *
	 * @param {string} username
	 * @param {string} repository
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubApi
	 */
	public getBranchesForRepository(
		username: string,
		repository: string,
		authenticationToken?: string,
		authenticationToken2?: string,
		options?: any,
	) {
		return GithubApiFp(this.configuration)
			.getBranchesForRepository(
				username,
				repository,
				authenticationToken,
				authenticationToken2,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} username
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubApi
	 */
	public getDockerRepository(
		username: string,
		authenticationToken?: string,
		authenticationToken2?: string,
		options?: any,
	) {
		return GithubApiFp(this.configuration)
			.getDockerRepository(
				username,
				authenticationToken,
				authenticationToken2,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} username
	 * @param {string} repository
	 * @param {string} branch
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubApi
	 */
	public getDockerfilesForRepository(
		username: string,
		repository: string,
		branch: string,
		authenticationToken?: string,
		authenticationToken2?: string,
		options?: any,
	) {
		return GithubApiFp(this.configuration)
			.getDockerfilesForRepository(
				username,
				repository,
				branch,
				authenticationToken,
				authenticationToken2,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} username
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubApi
	 */
	public getRepositories(
		username: string,
		authenticationToken?: string,
		authenticationToken2?: string,
		options?: any,
	) {
		return GithubApiFp(this.configuration)
			.getRepositories(
				username,
				authenticationToken,
				authenticationToken2,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * GithubWebhooksApi - axios parameter creator
 * @export
 */
export const GithubWebhooksApiAxiosParamCreator = function(
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @param {GithubPushWebhook} githubPushWebhook
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		push: async (
			githubPushWebhook: GithubPushWebhook,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'githubPushWebhook' is not null or undefined
			assertParamExists("push", "githubPushWebhook", githubPushWebhook);
			const localVarPath = `/api/github/webhook/push`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				githubPushWebhook,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * GithubWebhooksApi - functional programming interface
 * @export
 */
export const GithubWebhooksApiFp = function(configuration?: Configuration) {
	const localVarAxiosParamCreator =
		GithubWebhooksApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {GithubPushWebhook} githubPushWebhook
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async push(
			githubPushWebhook: GithubPushWebhook,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.push(
				githubPushWebhook,
				options,
			);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
	};
};

/**
 * GithubWebhooksApi - factory interface
 * @export
 */
export const GithubWebhooksApiFactory = function(
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = GithubWebhooksApiFp(configuration);
	return {
		/**
		 *
		 * @param {GithubPushWebhook} githubPushWebhook
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		push(
			githubPushWebhook: GithubPushWebhook,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.push(githubPushWebhook, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * GithubWebhooksApi - object-oriented interface
 * @export
 * @class GithubWebhooksApi
 * @extends {BaseAPI}
 */
export class GithubWebhooksApi extends BaseAPI {
	/**
	 *
	 * @param {GithubPushWebhook} githubPushWebhook
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubWebhooksApi
	 */
	public push(githubPushWebhook: GithubPushWebhook, options?: any) {
		return GithubWebhooksApiFp(this.configuration)
			.push(githubPushWebhook, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * OperationApi - axios parameter creator
 * @export
 */
export const OperationApiAxiosParamCreator = function(
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @param {DeployConfigModel} deployConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deploy: async (
			deployConfigModel: DeployConfigModel,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'deployConfigModel' is not null or undefined
			assertParamExists("deploy", "deployConfigModel", deployConfigModel);
			const localVarPath = `/api/automate/operation/deployment`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				deployConfigModel,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getConfig: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/automate/operation/config`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getMappings: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/automate/operation/mappings`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {InlineObject2} inlineObject2
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		register: async (
			inlineObject2: InlineObject2,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inlineObject2' is not null or undefined
			assertParamExists("register", "inlineObject2", inlineObject2);
			const localVarPath = `/api/automate/operation/register`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inlineObject2,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {BuildConfigModel} buildConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		start: async (
			buildConfigModel: BuildConfigModel,
			options: any = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'buildConfigModel' is not null or undefined
			assertParamExists("start", "buildConfigModel", buildConfigModel);
			const localVarPath = `/api/automate/operation/build`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query,
			);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				buildConfigModel,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * OperationApi - functional programming interface
 * @export
 */
export const OperationApiFp = function(configuration?: Configuration) {
	const localVarAxiosParamCreator =
		OperationApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {DeployConfigModel} deployConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deploy(
			deployConfigModel: DeployConfigModel,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deploy(
				deployConfigModel,
				options,
			);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getConfig(
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<HubConfig>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(
				options,
			);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getMappings(
			options?: any,
		): Promise<(
			axios?: AxiosInstance,
			basePath?: string,
		) => AxiosPromise<Array<MappingModel>>> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getMappings(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {InlineObject2} inlineObject2
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async register(
			inlineObject2: InlineObject2,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.register(
				inlineObject2,
				options,
			);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
		/**
		 *
		 * @param {BuildConfigModel} buildConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async start(
			buildConfigModel: BuildConfigModel,
			options?: any,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.start(
				buildConfigModel,
				options,
			);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration,
			);
		},
	};
};

/**
 * OperationApi - factory interface
 * @export
 */
export const OperationApiFactory = function(
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = OperationApiFp(configuration);
	return {
		/**
		 *
		 * @param {DeployConfigModel} deployConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deploy(
			deployConfigModel: DeployConfigModel,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.deploy(deployConfigModel, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getConfig(options?: any): AxiosPromise<HubConfig> {
			return localVarFp
				.getConfig(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getMappings(options?: any): AxiosPromise<Array<MappingModel>> {
			return localVarFp
				.getMappings(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {InlineObject2} inlineObject2
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		register(
			inlineObject2: InlineObject2,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.register(inlineObject2, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {BuildConfigModel} buildConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		start(
			buildConfigModel: BuildConfigModel,
			options?: any,
		): AxiosPromise<void> {
			return localVarFp
				.start(buildConfigModel, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * OperationApi - object-oriented interface
 * @export
 * @class OperationApi
 * @extends {BaseAPI}
 */
export class OperationApi extends BaseAPI {
	/**
	 *
	 * @param {DeployConfigModel} deployConfigModel
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationApi
	 */
	public deploy(deployConfigModel: DeployConfigModel, options?: any) {
		return OperationApiFp(this.configuration)
			.deploy(deployConfigModel, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationApi
	 */
	public getConfig(options?: any) {
		return OperationApiFp(this.configuration)
			.getConfig(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationApi
	 */
	public getMappings(options?: any) {
		return OperationApiFp(this.configuration)
			.getMappings(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {InlineObject2} inlineObject2
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationApi
	 */
	public register(inlineObject2: InlineObject2, options?: any) {
		return OperationApiFp(this.configuration)
			.register(inlineObject2, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {BuildConfigModel} buildConfigModel
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationApi
	 */
	public start(buildConfigModel: BuildConfigModel, options?: any) {
		return OperationApiFp(this.configuration)
			.start(buildConfigModel, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
