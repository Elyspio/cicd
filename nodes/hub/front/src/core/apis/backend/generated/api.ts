/* tslint:disable */
/* eslint-disable */
/**
 * Api documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosInstance, AxiosPromise } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import { assertParamExists, createRequestFunction, DUMMY_BASE_URL, serializeDataIfNeeded, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, toPathString } from "./common";
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from "./base";

/**
 *
 * @export
 * @interface BuildAgentModelReturn
 */
export interface BuildAgentModelReturn {
	/**
	 *
	 * @type {string}
	 * @memberof BuildAgentModelReturn
	 */
	uri: string;
	/**
	 *
	 * @type {string}
	 * @memberof BuildAgentModelReturn
	 */
	availability: BuildAgentModelReturnAvailabilityEnum;
	/**
	 *
	 * @type {string}
	 * @memberof BuildAgentModelReturn
	 */
	lastUptime?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof BuildAgentModelReturn
	 */
	abilities: Array<BuildAgentModelReturnAbilitiesEnum>;
}

/**
 * @export
 * @enum {string}
 */
export enum BuildAgentModelReturnAvailabilityEnum {
	Free = "free",
	Running = "running",
	Down = "down",
}

/**
 * @export
 * @enum {string}
 */
export enum BuildAgentModelReturnAbilitiesEnum {
	Docker = "docker",
	DockerBuildx = "docker-buildx",
}

/**
 *
 * @export
 * @interface BuildConfigModel
 */
export interface BuildConfigModel {
	/**
	 *
	 * @type {GithubConfigModel}
	 * @memberof BuildConfigModel
	 */
	github: GithubConfigModel;
	/**
	 *
	 * @type {DockerConfigModel}
	 * @memberof BuildConfigModel
	 */
	dockerfiles?: DockerConfigModel;
	/**
	 *
	 * @type {DockerBakeModel}
	 * @memberof BuildConfigModel
	 */
	bake?: DockerBakeModel;
}

/**
 *
 * @export
 * @interface DeployConfigModel
 */
export interface DeployConfigModel {
	/**
	 *
	 * @type {DockerField}
	 * @memberof DeployConfigModel
	 */
	docker: DockerField;
	/**
	 * URI of the production agent
	 * @type {string}
	 * @memberof DeployConfigModel
	 */
	uri: string;
}

/**
 *
 * @export
 * @interface DockerBakeModel
 */
export interface DockerBakeModel {
	/**
	 *
	 * @type {string}
	 * @memberof DockerBakeModel
	 */
	bakeFilePath: string;
}

/**
 *
 * @export
 * @interface DockerComposeField
 */
export interface DockerComposeField {
	/**
	 * Path where the docker-compose.yml file is
	 * @type {string}
	 * @memberof DockerComposeField
	 */
	path?: string;
}

/**
 *
 * @export
 * @interface DockerConfigModel
 */
export interface DockerConfigModel {
	/**
	 * Dockerfiles to build
	 * @type {Array<DockerFileConfigModel>}
	 * @memberof DockerConfigModel
	 */
	files: Array<DockerFileConfigModel>;
	/**
	 * Platforms available for the future image
	 * @type {Array<string>}
	 * @memberof DockerConfigModel
	 */
	platforms: Array<DockerConfigModelPlatformsEnum>;
	/**
	 *
	 * @type {string}
	 * @memberof DockerConfigModel
	 */
	username: string;
}

/**
 * @export
 * @enum {string}
 */
export enum DockerConfigModelPlatformsEnum {
	Arm64 = "linux/arm64",
	Amd64 = "linux/amd64",
}

/**
 *
 * @export
 * @interface DockerField
 */
export interface DockerField {
	/**
	 *
	 * @type {DockerComposeField}
	 * @memberof DockerField
	 */
	compose?: DockerComposeField;
}

/**
 *
 * @export
 * @interface DockerFileConfigModel
 */
export interface DockerFileConfigModel {
	/**
	 * Path to Dockerfile file
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	path: string;
	/**
	 * Working directory from origin
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	wd: string;
	/**
	 * Name for the image
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	image: string;
	/**
	 * Tag for the image
	 * @type {string}
	 * @memberof DockerFileConfigModel
	 */
	tag?: string;
}

/**
 *
 * @export
 * @interface FileModel
 */
export interface FileModel {
	/**
	 *
	 * @type {string}
	 * @memberof FileModel
	 */
	path: string;
	/**
	 *
	 * @type {string}
	 * @memberof FileModel
	 */
	key: string;
	/**
	 *
	 * @type {number}
	 * @memberof FileModel
	 */
	size: number;
}

/**
 *
 * @export
 * @interface FoldersModel
 */
export interface FoldersModel {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof FoldersModel
	 */
	apps: Array<string>;
}

/**
 *
 * @export
 * @interface GenericError
 */
export interface GenericError {
	/**
	 * The error name
	 * @type {string}
	 * @memberof GenericError
	 */
	name: string;
	/**
	 * An error message
	 * @type {string}
	 * @memberof GenericError
	 */
	message: string;

	[key: string]: object | any;
}

/**
 *
 * @export
 * @interface GithubConfigModel
 */
export interface GithubConfigModel {
	/**
	 * Url of the repo
	 * @type {string}
	 * @memberof GithubConfigModel
	 */
	remote: string;
	/**
	 * Branch on the repo
	 * @type {string}
	 * @memberof GithubConfigModel
	 */
	branch: string;
	/**
	 * Commit Sha
	 * @type {string}
	 * @memberof GithubConfigModel
	 */
	commit?: string;
}

/**
 *
 * @export
 * @interface GithubPushWebhook
 */
export interface GithubPushWebhook {
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	ref: string;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	before: string;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	after: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof GithubPushWebhook
	 */
	created: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof GithubPushWebhook
	 */
	deleted: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof GithubPushWebhook
	 */
	forced: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	base_ref: string;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	compare: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof GithubPushWebhook
	 */
	commits: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof GithubPushWebhook
	 */
	head_commit?: string;
	/**
	 *
	 * @type {Repository}
	 * @memberof GithubPushWebhook
	 */
	repository: Repository;
	/**
	 *
	 * @type {Pusher}
	 * @memberof GithubPushWebhook
	 */
	pusher: Pusher;
	/**
	 *
	 * @type {User}
	 * @memberof GithubPushWebhook
	 */
	sender: User;
}

/**
 *
 * @export
 * @interface HubAgentConfig
 */
export interface HubAgentConfig {
	/**
	 *
	 * @type {Array<ProductionAgentModel>}
	 * @memberof HubAgentConfig
	 */
	deployments: Array<ProductionAgentModel>;
	/**
	 *
	 * @type {Array<BuildAgentModelReturn>}
	 * @memberof HubAgentConfig
	 */
	builds: Array<BuildAgentModelReturn>;
}

/**
 *
 * @export
 * @interface HubConfig
 */
export interface HubConfig {
	/**
	 *
	 * @type {HubAgentConfig}
	 * @memberof HubConfig
	 */
	agents: HubAgentConfig;
	/**
	 *
	 * @type {JobsModel}
	 * @memberof HubConfig
	 */
	jobs: JobsModel;
	/**
	 *
	 * @type {Array<MappingModel>}
	 * @memberof HubConfig
	 */
	mappings: Array<MappingModel>;
	/**
	 *
	 * @type {JobsModel}
	 * @memberof HubConfig
	 */
	queues: JobsModel;
}

/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
	/**
	 *
	 * @type {BuildConfigModel}
	 * @memberof InlineObject
	 */
	build: BuildConfigModel;
	/**
	 *
	 * @type {DeployConfigModel}
	 * @memberof InlineObject
	 */
	deploy: DeployConfigModel;
}

/**
 *
 * @export
 * @interface JobBuildModel
 */
export interface JobBuildModel {
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	startedAt?: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	finishedAt?: string;
	/**
	 *
	 * @type {number}
	 * @memberof JobBuildModel
	 */
	id: number;
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	stdout?: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobBuildModel
	 */
	error?: string;
	/**
	 *
	 * @type {BuildConfigModel}
	 * @memberof JobBuildModel
	 */
	config: BuildConfigModel;
}

/**
 *
 * @export
 * @interface JobDeployModel
 */
export interface JobDeployModel {
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	startedAt?: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	finishedAt?: string;
	/**
	 *
	 * @type {number}
	 * @memberof JobDeployModel
	 */
	id: number;
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	stdout?: string;
	/**
	 *
	 * @type {string}
	 * @memberof JobDeployModel
	 */
	error?: string;
	/**
	 *
	 * @type {DeployConfigModel}
	 * @memberof JobDeployModel
	 */
	config: DeployConfigModel;
}

/**
 *
 * @export
 * @interface JobsModel
 */
export interface JobsModel {
	/**
	 *
	 * @type {Array<JobBuildModel>}
	 * @memberof JobsModel
	 */
	builds: Array<JobBuildModel>;
	/**
	 *
	 * @type {Array<JobDeployModel>}
	 * @memberof JobsModel
	 */
	deployments: Array<JobDeployModel>;
}

/**
 *
 * @export
 * @interface MappingModel
 */
export interface MappingModel {
	/**
	 *
	 * @type {BuildConfigModel}
	 * @memberof MappingModel
	 */
	build: BuildConfigModel;
	/**
	 *
	 * @type {DeployConfigModel}
	 * @memberof MappingModel
	 */
	deploy: DeployConfigModel;
	/**
	 *
	 * @type {number}
	 * @memberof MappingModel
	 */
	id: number;
}

/**
 *
 * @export
 * @interface NotFound
 */
export interface NotFound {
	/**
	 * The error name
	 * @type {string}
	 * @memberof NotFound
	 */
	name: string;
	/**
	 * An error message
	 * @type {string}
	 * @memberof NotFound
	 */
	message: string;
	/**
	 * The status code of the exception
	 * @type {number}
	 * @memberof NotFound
	 */
	status: number;
	/**
	 * A list of related errors
	 * @type {Array<GenericError>}
	 * @memberof NotFound
	 */
	errors?: Array<GenericError>;
	/**
	 * The stack trace (only in development mode)
	 * @type {string}
	 * @memberof NotFound
	 */
	stack?: string;
}

/**
 *
 * @export
 * @interface ProductionAgentModel
 */
export interface ProductionAgentModel {
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModel
	 */
	uri: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModel
	 */
	availability: ProductionAgentModelAvailabilityEnum;
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModel
	 */
	lastUptime?: string;
	/**
	 *
	 * @type {Array<ProductionAgentModelAddAbilities>}
	 * @memberof ProductionAgentModel
	 */
	abilities: Array<ProductionAgentModelAddAbilities>;
	/**
	 *
	 * @type {FoldersModel}
	 * @memberof ProductionAgentModel
	 */
	folders: FoldersModel;
}

/**
 * @export
 * @enum {string}
 */
export enum ProductionAgentModelAvailabilityEnum {
	Free = "free",
	Running = "running",
	Down = "down",
}

/**
 *
 * @export
 * @interface ProductionAgentModelAddAbilities
 */
export interface ProductionAgentModelAddAbilities {
	/**
	 *
	 * @type {string}
	 * @memberof ProductionAgentModelAddAbilities
	 */
	type: ProductionAgentModelAddAbilitiesTypeEnum;
	/**
	 *
	 * @type {ProductionAgentModelAddAbilitiesDockerCompose}
	 * @memberof ProductionAgentModelAddAbilities
	 */
	dockerCompose?: ProductionAgentModelAddAbilitiesDockerCompose;
}

/**
 * @export
 * @enum {string}
 */
export enum ProductionAgentModelAddAbilitiesTypeEnum {
	DockerCompose = "docker-compose",
	Docker = "docker",
}

/**
 *
 * @export
 * @interface ProductionAgentModelAddAbilitiesDockerCompose
 */
export interface ProductionAgentModelAddAbilitiesDockerCompose {
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductionAgentModelAddAbilitiesDockerCompose
	 */
	isDockerComposeIntegratedToCli: boolean;
}

/**
 *
 * @export
 * @interface ProductionApplications
 */
export interface ProductionApplications {
	/**
	 *
	 * @type {ProductionAgentModel}
	 * @memberof ProductionApplications
	 */
	agent: ProductionAgentModel;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ProductionApplications
	 */
	apps: Array<string>;
}

/**
 *
 * @export
 * @interface Pusher
 */
export interface Pusher {
	/**
	 *
	 * @type {string}
	 * @memberof Pusher
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Pusher
	 */
	email: string;
}

/**
 *
 * @export
 * @interface RepoNodeModel
 */
export interface RepoNodeModel {
	/**
	 *
	 * @type {string}
	 * @memberof RepoNodeModel
	 */
	path: string;
	/**
	 *
	 * @type {string}
	 * @memberof RepoNodeModel
	 */
	type: RepoNodeModelTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum RepoNodeModelTypeEnum {
	Folder = "folder",
	File = "file",
}

/**
 *
 * @export
 * @interface RepoWithBranchModel
 */
export interface RepoWithBranchModel {
	/**
	 *
	 * @type {string}
	 * @memberof RepoWithBranchModel
	 */
	branch: string;
	/**
	 *
	 * @type {string}
	 * @memberof RepoWithBranchModel
	 */
	repo: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof RepoWithBranchModel
	 */
	dockerfiles: Array<string>;
	/**
	 *
	 * @type {Array<RepoNodeModel>}
	 * @memberof RepoWithBranchModel
	 */
	nodes: Array<RepoNodeModel>;
	/**
	 *
	 * @type {string}
	 * @memberof RepoWithBranchModel
	 */
	bake?: string;
}

/**
 *
 * @export
 * @interface Repository
 */
export interface Repository {
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	id: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	node_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	full_name: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	_private: boolean;
	/**
	 *
	 * @type {User}
	 * @memberof Repository
	 */
	owner: User;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	html_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	description: string | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	fork: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	forks_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	keys_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	collaborators_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	teams_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	hooks_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	issue_events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	assignees_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	branches_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	tags_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	blobs_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_tags_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_refs_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	trees_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	statuses_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	languages_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	stargazers_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	contributors_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	subscribers_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	subscription_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	commits_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_commits_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	comments_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	issue_comment_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	contents_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	compare_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	merges_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	archive_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	downloads_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	issues_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	pulls_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	milestones_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	notifications_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	labels_url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	releases_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	deployments_url: string;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	created_at: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	updated_at: string;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	pushed_at: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	git_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	ssh_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	clone_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	svn_url: string;
	/**
	 *
	 * @type {object}
	 * @memberof Repository
	 */
	homepage: object;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	size: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	stargazers_count: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	watchers_count: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	language: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_issues: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_projects: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_downloads: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_wiki: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	has_pages: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	forks_count: number;
	/**
	 *
	 * @type {object}
	 * @memberof Repository
	 */
	mirror_url: object;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	archived: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Repository
	 */
	disabled: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	open_issues_count: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	license: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	forks: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	open_issues: number;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	watchers: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	default_branch: string;
	/**
	 *
	 * @type {number}
	 * @memberof Repository
	 */
	stargazers: number;
	/**
	 *
	 * @type {string}
	 * @memberof Repository
	 */
	master_branch: string;
}

/**
 *
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
	/**
	 * The error name
	 * @type {string}
	 * @memberof Unauthorized
	 */
	name: string;
	/**
	 * An error message
	 * @type {string}
	 * @memberof Unauthorized
	 */
	message: string;
	/**
	 * The status code of the exception
	 * @type {number}
	 * @memberof Unauthorized
	 */
	status: number;
	/**
	 * A list of related errors
	 * @type {Array<GenericError>}
	 * @memberof Unauthorized
	 */
	errors?: Array<GenericError>;
	/**
	 * The stack trace (only in development mode)
	 * @type {string}
	 * @memberof Unauthorized
	 */
	stack?: string;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	email: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	login: string;
	/**
	 *
	 * @type {number}
	 * @memberof User
	 */
	id: number;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	node_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	avatar_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	gravatar_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	html_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	followers_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	following_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	gists_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	starred_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	subscriptions_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	organizations_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	repos_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	received_events_url: string;
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	type: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof User
	 */
	site_admin: boolean;
}

/**
 * AutomateApi - axios parameter creator
 * @export
 */
export const AutomateApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {DeployConfigModel} deployConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deploy: async (deployConfigModel: DeployConfigModel, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'deployConfigModel' is not null or undefined
			assertParamExists("deploy", "deployConfigModel", deployConfigModel);
			const localVarPath = `/api/automate/deployment`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(deployConfigModel, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getConfig: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/automate/config`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {BuildConfigModel} buildConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		start: async (buildConfigModel: BuildConfigModel, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'buildConfigModel' is not null or undefined
			assertParamExists("start", "buildConfigModel", buildConfigModel);
			const localVarPath = `/api/automate/build`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(buildConfigModel, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * AutomateApi - functional programming interface
 * @export
 */
export const AutomateApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AutomateApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {DeployConfigModel} deployConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deploy(deployConfigModel: DeployConfigModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deploy(deployConfigModel, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getConfig(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HubConfig>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {BuildConfigModel} buildConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async start(buildConfigModel: BuildConfigModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.start(buildConfigModel, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * AutomateApi - factory interface
 * @export
 */
export const AutomateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = AutomateApiFp(configuration);
	return {
		/**
		 *
		 * @param {DeployConfigModel} deployConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deploy(deployConfigModel: DeployConfigModel, options?: any): AxiosPromise<void> {
			return localVarFp.deploy(deployConfigModel, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getConfig(options?: any): AxiosPromise<HubConfig> {
			return localVarFp.getConfig(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {BuildConfigModel} buildConfigModel
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		start(buildConfigModel: BuildConfigModel, options?: any): AxiosPromise<void> {
			return localVarFp.start(buildConfigModel, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * AutomateApi - object-oriented interface
 * @export
 * @class AutomateApi
 * @extends {BaseAPI}
 */
export class AutomateApi extends BaseAPI {
	/**
	 *
	 * @param {DeployConfigModel} deployConfigModel
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomateApi
	 */
	public deploy(deployConfigModel: DeployConfigModel, options?: any) {
		return AutomateApiFp(this.configuration)
			.deploy(deployConfigModel, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomateApi
	 */
	public getConfig(options?: any) {
		return AutomateApiFp(this.configuration)
			.getConfig(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {BuildConfigModel} buildConfigModel
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AutomateApi
	 */
	public start(buildConfigModel: BuildConfigModel, options?: any) {
		return AutomateApiFp(this.configuration)
			.start(buildConfigModel, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * DockerApi - axios parameter creator
 * @export
 */
export const DockerApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {Array<'web-front' | 'web-back'>} [preset]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		get: async (preset?: Array<"web-front" | "web-back">, options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/docker/dockerfiles`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (preset) {
				localVarQueryParameter["preset"] = preset;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * DockerApi - functional programming interface
 * @export
 */
export const DockerApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = DockerApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {Array<'web-front' | 'web-back'>} [preset]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async get(preset?: Array<"web-front" | "web-back">, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.get(preset, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * DockerApi - factory interface
 * @export
 */
export const DockerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = DockerApiFp(configuration);
	return {
		/**
		 *
		 * @param {Array<'web-front' | 'web-back'>} [preset]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		get(preset?: Array<"web-front" | "web-back">, options?: any): AxiosPromise<string> {
			return localVarFp.get(preset, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * DockerApi - object-oriented interface
 * @export
 * @class DockerApi
 * @extends {BaseAPI}
 */
export class DockerApi extends BaseAPI {
	/**
	 *
	 * @param {Array<'web-front' | 'web-back'>} [preset]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DockerApi
	 */
	public get(preset?: Array<"web-front" | "web-back">, options?: any) {
		return DockerApiFp(this.configuration)
			.get(preset, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * GithubUsersApi - axios parameter creator
 * @export
 */
export const GithubUsersApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBranchesForRepository: async (username: string, repository: string, authenticationToken?: string, authenticationToken2?: string, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists("getBranchesForRepository", "username", username);
			// verify required parameter 'repository' is not null or undefined
			assertParamExists("getBranchesForRepository", "repository", repository);
			const localVarPath = `/api/github/users/{username}/repositories/{repository}/branches`
				.replace(`{${"username"}}`, encodeURIComponent(String(username)))
				.replace(`{${"repository"}}`, encodeURIComponent(String(repository)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (authenticationToken !== undefined && authenticationToken !== null) {
				localVarHeaderParameter["authentication-token"] = String(authenticationToken);
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerRepository: async (username: string, authenticationToken?: string, authenticationToken2?: string, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists("getDockerRepository", "username", username);
			const localVarPath = `/api/github/users/{username}/repositories/dockerfiles`.replace(`{${"username"}}`, encodeURIComponent(String(username)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (authenticationToken !== undefined && authenticationToken !== null) {
				localVarHeaderParameter["authentication-token"] = String(authenticationToken);
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} branch
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerfilesForRepository: async (
			username: string,
			repository: string,
			branch: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists("getDockerfilesForRepository", "username", username);
			// verify required parameter 'repository' is not null or undefined
			assertParamExists("getDockerfilesForRepository", "repository", repository);
			// verify required parameter 'branch' is not null or undefined
			assertParamExists("getDockerfilesForRepository", "branch", branch);
			const localVarPath = `/api/github/users/{username}/repositories/{repository}/branches/{branch}/dockerfiles`
				.replace(`{${"username"}}`, encodeURIComponent(String(username)))
				.replace(`{${"repository"}}`, encodeURIComponent(String(repository)))
				.replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (authenticationToken !== undefined && authenticationToken !== null) {
				localVarHeaderParameter["authentication-token"] = String(authenticationToken);
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRepositories: async (username: string, authenticationToken?: string, authenticationToken2?: string, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'username' is not null or undefined
			assertParamExists("getRepositories", "username", username);
			const localVarPath = `/api/github/users/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(username)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (authenticationToken !== undefined && authenticationToken !== null) {
				localVarHeaderParameter["authentication-token"] = String(authenticationToken);
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * GithubUsersApi - functional programming interface
 * @export
 */
export const GithubUsersApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = GithubUsersApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBranchesForRepository(
			username: string,
			repository: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getBranchesForRepository(username, repository, authenticationToken, authenticationToken2, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getDockerRepository(
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoWithBranchModel>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getDockerRepository(username, authenticationToken, authenticationToken2, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} branch
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getDockerfilesForRepository(
			username: string,
			repository: string,
			branch: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileModel>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getDockerfilesForRepository(username, repository, branch, authenticationToken, authenticationToken2, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getRepositories(
			username: string,
			authenticationToken?: string,
			authenticationToken2?: string,
			options?: any
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositories(username, authenticationToken, authenticationToken2, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * GithubUsersApi - factory interface
 * @export
 */
export const GithubUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = GithubUsersApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBranchesForRepository(username: string, repository: string, authenticationToken?: string, authenticationToken2?: string, options?: any): AxiosPromise<Array<string>> {
			return localVarFp.getBranchesForRepository(username, repository, authenticationToken, authenticationToken2, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerRepository(username: string, authenticationToken?: string, authenticationToken2?: string, options?: any): AxiosPromise<Array<RepoWithBranchModel>> {
			return localVarFp.getDockerRepository(username, authenticationToken, authenticationToken2, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} repository
		 * @param {string} branch
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDockerfilesForRepository(username: string, repository: string, branch: string, authenticationToken?: string, authenticationToken2?: string, options?: any): AxiosPromise<Array<FileModel>> {
			return localVarFp.getDockerfilesForRepository(username, repository, branch, authenticationToken, authenticationToken2, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} username
		 * @param {string} [authenticationToken]
		 * @param {string} [authenticationToken2]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRepositories(username: string, authenticationToken?: string, authenticationToken2?: string, options?: any): AxiosPromise<Array<string>> {
			return localVarFp.getRepositories(username, authenticationToken, authenticationToken2, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * GithubUsersApi - object-oriented interface
 * @export
 * @class GithubUsersApi
 * @extends {BaseAPI}
 */
export class GithubUsersApi extends BaseAPI {
	/**
	 *
	 * @param {string} username
	 * @param {string} repository
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubUsersApi
	 */
	public getBranchesForRepository(username: string, repository: string, authenticationToken?: string, authenticationToken2?: string, options?: any) {
		return GithubUsersApiFp(this.configuration)
			.getBranchesForRepository(username, repository, authenticationToken, authenticationToken2, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} username
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubUsersApi
	 */
	public getDockerRepository(username: string, authenticationToken?: string, authenticationToken2?: string, options?: any) {
		return GithubUsersApiFp(this.configuration)
			.getDockerRepository(username, authenticationToken, authenticationToken2, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} username
	 * @param {string} repository
	 * @param {string} branch
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubUsersApi
	 */
	public getDockerfilesForRepository(username: string, repository: string, branch: string, authenticationToken?: string, authenticationToken2?: string, options?: any) {
		return GithubUsersApiFp(this.configuration)
			.getDockerfilesForRepository(username, repository, branch, authenticationToken, authenticationToken2, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} username
	 * @param {string} [authenticationToken]
	 * @param {string} [authenticationToken2]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubUsersApi
	 */
	public getRepositories(username: string, authenticationToken?: string, authenticationToken2?: string, options?: any) {
		return GithubUsersApiFp(this.configuration)
			.getRepositories(username, authenticationToken, authenticationToken2, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * GithubWebhooksApi - axios parameter creator
 * @export
 */
export const GithubWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {GithubPushWebhook} githubPushWebhook
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		push: async (githubPushWebhook: GithubPushWebhook, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'githubPushWebhook' is not null or undefined
			assertParamExists("push", "githubPushWebhook", githubPushWebhook);
			const localVarPath = `/api/github/webhook/push`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(githubPushWebhook, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * GithubWebhooksApi - functional programming interface
 * @export
 */
export const GithubWebhooksApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = GithubWebhooksApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {GithubPushWebhook} githubPushWebhook
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async push(githubPushWebhook: GithubPushWebhook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.push(githubPushWebhook, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * GithubWebhooksApi - factory interface
 * @export
 */
export const GithubWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = GithubWebhooksApiFp(configuration);
	return {
		/**
		 *
		 * @param {GithubPushWebhook} githubPushWebhook
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		push(githubPushWebhook: GithubPushWebhook, options?: any): AxiosPromise<void> {
			return localVarFp.push(githubPushWebhook, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * GithubWebhooksApi - object-oriented interface
 * @export
 * @class GithubWebhooksApi
 * @extends {BaseAPI}
 */
export class GithubWebhooksApi extends BaseAPI {
	/**
	 *
	 * @param {GithubPushWebhook} githubPushWebhook
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GithubWebhooksApi
	 */
	public push(githubPushWebhook: GithubPushWebhook, options?: any) {
		return GithubWebhooksApiFp(this.configuration)
			.push(githubPushWebhook, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * OperationAgentsApi - axios parameter creator
 * @export
 */
export const OperationAgentsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBuilderAgent: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/operations/agents/agent/build`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionAgent: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/operations/agents/agent/production`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionApps: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/operations/agents/agent/production/node`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * OperationAgentsApi - functional programming interface
 * @export
 */
export const OperationAgentsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = OperationAgentsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBuilderAgent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildAgentModelReturn>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getBuilderAgent(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getProductionAgent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductionAgentModel>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getProductionAgent(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getProductionApps(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductionApplications>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getProductionApps(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * OperationAgentsApi - factory interface
 * @export
 */
export const OperationAgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = OperationAgentsApiFp(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBuilderAgent(options?: any): AxiosPromise<Array<BuildAgentModelReturn>> {
			return localVarFp.getBuilderAgent(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionAgent(options?: any): AxiosPromise<Array<ProductionAgentModel>> {
			return localVarFp.getProductionAgent(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProductionApps(options?: any): AxiosPromise<Array<ProductionApplications>> {
			return localVarFp.getProductionApps(options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * OperationAgentsApi - object-oriented interface
 * @export
 * @class OperationAgentsApi
 * @extends {BaseAPI}
 */
export class OperationAgentsApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationAgentsApi
	 */
	public getBuilderAgent(options?: any) {
		return OperationAgentsApiFp(this.configuration)
			.getBuilderAgent(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationAgentsApi
	 */
	public getProductionAgent(options?: any) {
		return OperationAgentsApiFp(this.configuration)
			.getProductionAgent(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationAgentsApi
	 */
	public getProductionApps(options?: any) {
		return OperationAgentsApiFp(this.configuration)
			.getProductionApps(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * OperationJobsApi - axios parameter creator
 * @export
 */
export const OperationJobsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {'build' | 'deployment'} type
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		_delete: async (type: "build" | "deployment", id: number, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'type' is not null or undefined
			assertParamExists("_delete", "type", type);
			// verify required parameter 'id' is not null or undefined
			assertParamExists("_delete", "id", id);
			const localVarPath = `/api/operations/jobs/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(type))).replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * OperationJobsApi - functional programming interface
 * @export
 */
export const OperationJobsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = OperationJobsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {'build' | 'deployment'} type
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async _delete(type: "build" | "deployment", id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator._delete(type, id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * OperationJobsApi - factory interface
 * @export
 */
export const OperationJobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = OperationJobsApiFp(configuration);
	return {
		/**
		 *
		 * @param {'build' | 'deployment'} type
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		_delete(type: "build" | "deployment", id: number, options?: any): AxiosPromise<void> {
			return localVarFp._delete(type, id, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * OperationJobsApi - object-oriented interface
 * @export
 * @class OperationJobsApi
 * @extends {BaseAPI}
 */
export class OperationJobsApi extends BaseAPI {
	/**
	 *
	 * @param {'build' | 'deployment'} type
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationJobsApi
	 */
	public _delete(type: "build" | "deployment", id: number, options?: any) {
		return OperationJobsApiFp(this.configuration)
			._delete(type, id, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * OperationMappingsApi - axios parameter creator
 * @export
 */
export const OperationMappingsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Delete a mapping from its id
		 * @param {number} id Mapping id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		_delete: async (id: number, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("_delete", "id", id);
			const localVarPath = `/api/operations/mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Add a new mapping
		 * @param {InlineObject} inlineObject
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		add: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'inlineObject' is not null or undefined
			assertParamExists("add", "inlineObject", inlineObject);
			const localVarPath = `/api/operations/mappings`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get all mappings
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		get: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/operations/mappings`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Run a mapping from its id
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		run: async (id: number, options: any = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("run", "id", id);
			const localVarPath = `/api/operations/mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * OperationMappingsApi - functional programming interface
 * @export
 */
export const OperationMappingsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = OperationMappingsApiAxiosParamCreator(configuration);
	return {
		/**
		 * Delete a mapping from its id
		 * @param {number} id Mapping id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async _delete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 * Add a new mapping
		 * @param {InlineObject} inlineObject
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async add(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.add(inlineObject, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 * Get all mappings
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async get(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MappingModel>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 * Run a mapping from its id
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async run(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.run(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * OperationMappingsApi - factory interface
 * @export
 */
export const OperationMappingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = OperationMappingsApiFp(configuration);
	return {
		/**
		 * Delete a mapping from its id
		 * @param {number} id Mapping id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		_delete(id: number, options?: any): AxiosPromise<void> {
			return localVarFp._delete(id, options).then((request) => request(axios, basePath));
		},
		/**
		 * Add a new mapping
		 * @param {InlineObject} inlineObject
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		add(inlineObject: InlineObject, options?: any): AxiosPromise<number> {
			return localVarFp.add(inlineObject, options).then((request) => request(axios, basePath));
		},
		/**
		 * Get all mappings
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		get(options?: any): AxiosPromise<Array<MappingModel>> {
			return localVarFp.get(options).then((request) => request(axios, basePath));
		},
		/**
		 * Run a mapping from its id
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		run(id: number, options?: any): AxiosPromise<void> {
			return localVarFp.run(id, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * OperationMappingsApi - object-oriented interface
 * @export
 * @class OperationMappingsApi
 * @extends {BaseAPI}
 */
export class OperationMappingsApi extends BaseAPI {
	/**
	 * Delete a mapping from its id
	 * @param {number} id Mapping id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationMappingsApi
	 */
	public _delete(id: number, options?: any) {
		return OperationMappingsApiFp(this.configuration)
			._delete(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Add a new mapping
	 * @param {InlineObject} inlineObject
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationMappingsApi
	 */
	public add(inlineObject: InlineObject, options?: any) {
		return OperationMappingsApiFp(this.configuration)
			.add(inlineObject, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get all mappings
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationMappingsApi
	 */
	public get(options?: any) {
		return OperationMappingsApiFp(this.configuration)
			.get(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Run a mapping from its id
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OperationMappingsApi
	 */
	public run(id: number, options?: any) {
		return OperationMappingsApiFp(this.configuration)
			.run(id, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
